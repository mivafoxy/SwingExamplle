package com.company.mivafox;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class TicTacToeWindow extends JFrame
{
    public TicTacToeWindow()
    {
        // Инициализация окна.

        setVisible(true); // Сделать видимым.
        setResizable(false); // Делаю так, чтобы растянуть или сжать его было невозможно.
        setLocation(200, 200);   // Устанавливаю в заданную позицию
        setSize(300,300); // с заданными размерами.

        this.init(); // Дальнейшую инициализацию вынес в отдельный метод. Для удобства, чтобы
        // не нагромождать конструктор.
    }

    private void init()
    {
        // Делаю сетку 3*3 для того, чтобы на нее наложить все кнопки.
        JPanel panel = new JPanel(new GridLayout(3, 3));
        JButton[] buttons = new JButton[9]; // Делаю 9 кнопок для дальнейшей генерации поля 3x3

        // В цикле я каждую кнопку инициализирую, в том плане что:
        // 1. Накладываю ее на JPanel.
        // 2. Задаю поведение при нажатии на неё пользователем.
        for (int button = 0; button < buttons.length; button++)
        {
            // см. описание зачем это в actionPerformed методе
            final int requiredButton = button;

            // пока кнопка просто напросто с пустым текстом
            buttons[button] = new JButton("");

            // Далее надо сказать, что эта кнопка должна делать по нажатию. Для этого
            // и нужно как раз пользоваться ActionListener.
            buttons[button].addActionListener(new ActionListener() // По сути, когда в addActionListener засовывается созданный извне объект
                // - button будет с ним (объектом) работать. Вспомните пример с 7 занятия - как кошки работали с тарелками.
            {
                // Это же - обычная перегрузка метода. Весь этот механизм в целом называется анонимный класс. То есть, он нигде не прописан отдельно,
                // как тот же TicTacToeWindow, а одновременно описывается и создается именно в этом вот месте -
                // при запихивании обработчика событий в кнопку. И каждый раз, когда эта конструкция итеративно вызываться будет в цикле -
                // это будет совершенно новый объект. И да, пока достаточно знать, что таким образом можно обращаться
                // к членам текущего класса.
                @Override
                public void actionPerformed(ActionEvent e)
                {
                    // Пока запоминаем - объявляя вот такие конструкции в виде анонимных классов,
                    // они требуют, чтобы все используемые переменные метода (в данном случае - init()), или
                    // класса были константными и ни в коем случае извне никак не менялись.
                    buttons[requiredButton].setText("X");
                }
            });

            // После инициализации кнопки - ее необходимо добавить на наш холст JPanel.
            panel.add(buttons[button]);
        }

        // После прогона цикла холст сам необходимо добавить на само окно непосредственно.
        add(panel, BorderLayout.CENTER);
    }
}
